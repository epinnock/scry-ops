# scry-sbcov Implementation Plan — Story Capture Service

## Goal

Add a unified `captureStory()` primitive that captures multiple outputs (verification, screenshots, Figma layers, DOM snapshots) in a single browser session, while maintaining full backward compatibility with `executeStories()`.

---

## File-by-file Plan

### 1) [`scry-sbcov/src/types/figma.ts`](scry-sbcov/src/types/figma.ts) (NEW)

Figma LayerNode types matching html-to-figma and code.to.design output:

```typescript
export type LayerNode = FrameLayer | TextLayer | RectangleLayer | SvgLayer | GroupLayer;

export interface FrameLayer {
  type: 'FRAME';
  x?: number;
  y?: number;
  width?: number;
  height?: number;
  children?: LayerNode[];
  fills?: Paint[];
  strokes?: Paint[];
  cornerRadius?: number;
  clipsContent?: boolean;
  constraints?: Constraints;
}

export interface TextLayer {
  type: 'TEXT';
  characters?: string;
  fontSize?: number;
  fontFamily?: string;
  fills?: Paint[];
  // ... other text properties
}

// ... RectangleLayer, SvgLayer, GroupLayer, Paint, Constraints
```

### 2) [`scry-sbcov/src/types/index.ts`](scry-sbcov/src/types/index.ts)

Extend with capture-related interfaces:

```typescript
// Add new interfaces
export interface CaptureOptions {
  verify?: boolean;
  screenshot?: boolean | 'always' | 'on-failure';
  figmaLayers?: boolean | FigmaLayerOptions;
  domSnapshot?: boolean;
  timeout?: number;
  waitForSelector?: string;
  settleDelay?: number;
  viewport?: { width: number; height: number };
  screenshotDir?: string;
  artifactBaseUrl?: string;
}

export interface FigmaLayerOptions {
  converter: 'html-to-figma' | 'code-to-design';
  apiKey?: string;
  apiUrl?: string;
}

export interface CaptureResult {
  storyId: string;
  url: string;
  duration: number;
  verification?: VerificationResult;
  screenshot?: ScreenshotResult;
  figmaLayers?: LayerNode;
  domSnapshot?: string;
  consoleOutput?: ConsoleMessage[];
  captureErrors?: CaptureError[];
}

export interface VerificationResult {
  status: 'passed' | 'failed';
  errors: string[];
  warnings: string[];
  playFunctionStatus: 'passed' | 'failed' | 'none';
  failure?: { type: StoryFailureType; message: string; stack: string | null };
}

export interface ScreenshotResult {
  buffer: Buffer;
  path?: string;
  url?: string;
}

export interface BrowserSession {
  capture(url: string, storyId: string, options?: CaptureOptions): Promise<CaptureResult>;
  captureMany(url: string, storyIds: string[], options?: CaptureOptions & { concurrency?: number }): Promise<CaptureResult[]>;
  close(): Promise<void>;
  isActive(): boolean;
}

// Export from figma.ts
export type { LayerNode } from './figma.js';
```

### 3) [`scry-sbcov/src/figma/html-to-figma.bundle.ts`](scry-sbcov/src/figma/html-to-figma.bundle.ts) (NEW)

Bundled browser code for local DOM→Figma extraction:

```typescript
// Auto-generated by scripts/bundle-html-to-figma.mjs
export const HTML_TO_FIGMA_BUNDLE = `...bundled IIFE code...`;

export async function injectHtmlToFigma(page: import('playwright').Page): Promise<void> {
  await page.addScriptTag({ content: HTML_TO_FIGMA_BUNDLE });
}

export async function extractWithHtmlToFigma(
  page: import('playwright').Page,
  selector: string
): Promise<import('../types/figma.js').LayerNode | null> {
  return page.evaluate((sel) => {
    // @ts-expect-error - htmlToFigma injected at runtime
    return window.htmlToFigma(sel);
  }, selector);
}
```

### 4) [`scry-sbcov/src/figma/code-to-design.ts`](scry-sbcov/src/figma/code-to-design.ts) (NEW)

API client for code.to.design cloud conversion:

```typescript
const DEFAULT_API_URL = 'https://api.to.design/html';

export async function extractWithCodeToDesign(
  html: string,
  css: string,
  options: { apiKey: string; apiUrl?: string }
): Promise<{ model: import('../types/figma.js').LayerNode; images: unknown[] }> {
  const response = await fetch(options.apiUrl || DEFAULT_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${options.apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ html: `<style>${css}</style>${html}`, clip: false }),
  });

  if (!response.ok) {
    throw new Error(`code.to.design API error: ${response.status}`);
  }

  return response.json();
}
```

### 5) [`scry-sbcov/src/figma/index.ts`](scry-sbcov/src/figma/index.ts) (NEW)

Unified interface dispatching to either converter:

```typescript
import { injectHtmlToFigma, extractWithHtmlToFigma } from './html-to-figma.bundle.js';
import { extractWithCodeToDesign } from './code-to-design.js';
import type { FigmaLayerOptions, LayerNode } from '../types/index.js';
import type { Page } from 'playwright';

export async function extractFigmaLayers(
  page: Page,
  selector: string,
  options: FigmaLayerOptions | true
): Promise<LayerNode | null> {
  const opts: FigmaLayerOptions = options === true
    ? { converter: 'html-to-figma' }
    : options;

  if (opts.converter === 'html-to-figma') {
    await injectHtmlToFigma(page);
    return extractWithHtmlToFigma(page, selector);
  }

  if (opts.converter === 'code-to-design') {
    if (!opts.apiKey) throw new Error('code-to-design requires apiKey');

    const { html, css } = await page.evaluate((sel) => {
      const el = document.querySelector(sel);
      return {
        html: el?.innerHTML || '',
        css: Array.from(document.styleSheets)
          .flatMap(s => { try { return Array.from(s.cssRules || []); } catch { return []; } })
          .map(r => r.cssText)
          .join('\n'),
      };
    }, selector);

    const result = await extractWithCodeToDesign(html, css, opts);
    return result.model;
  }

  throw new Error(`Unknown converter: ${(opts as any).converter}`);
}
```

### 6) [`scry-sbcov/src/core/browser-session.ts`](scry-sbcov/src/core/browser-session.ts) (NEW)

Browser lifecycle management:

```typescript
import type { Browser, BrowserContext } from 'playwright';
import type { BrowserSession, BrowserSessionOptions, CaptureOptions, CaptureResult } from '../types/index.js';
import { captureStoryInternal } from './story-capture.js';

let playwright: typeof import('playwright') | null = null;

async function loadPlaywright(): Promise<typeof import('playwright')> {
  if (playwright) return playwright;
  try {
    playwright = await import('playwright');
    return playwright;
  } catch {
    throw new Error('Playwright not installed. Run: npm install playwright');
  }
}

export async function createBrowserSession(
  options: BrowserSessionOptions = {}
): Promise<BrowserSession> {
  const pw = await loadPlaywright();
  const browser = await pw[options.browser || 'chromium'].launch({
    headless: options.headless !== false,
  });
  const context = await browser.newContext({
    viewport: options.viewport || { width: 1280, height: 720 },
  });

  let closed = false;

  return {
    async capture(storybookUrl, storyId, captureOptions) {
      if (closed) throw new Error('Session is closed');
      return captureStoryInternal(context, storybookUrl, storyId, captureOptions);
    },

    async captureMany(storybookUrl, storyIds, captureOptions) {
      if (closed) throw new Error('Session is closed');
      const concurrency = captureOptions?.concurrency || 4;
      const results: CaptureResult[] = [];

      for (let i = 0; i < storyIds.length; i += concurrency) {
        const batch = storyIds.slice(i, i + concurrency);
        const batchResults = await Promise.all(
          batch.map(id => this.capture(storybookUrl, id, captureOptions))
        );
        results.push(...batchResults);
      }
      return results;
    },

    async close() {
      if (!closed) {
        closed = true;
        await context.close();
        await browser.close();
      }
    },

    isActive: () => !closed,
  };
}
```

### 7) [`scry-sbcov/src/core/story-capture.ts`](scry-sbcov/src/core/story-capture.ts) (NEW)

Core capture logic:

```typescript
import type { BrowserContext, Page } from 'playwright';
import * as fs from 'node:fs';
import * as path from 'node:path';
import type { CaptureOptions, CaptureResult, VerificationResult, ScreenshotResult, ConsoleMessage, CaptureError, StoryFailureType } from '../types/index.js';
import { extractFigmaLayers } from '../figma/index.js';
import { buildScreenshotArtifact } from './artifact-utils.js';

const DEFAULT_OPTIONS = {
  verify: true,
  screenshot: false,
  figmaLayers: false,
  domSnapshot: false,
  timeout: 15000,
  waitForSelector: '#storybook-root',
  settleDelay: 100,
  viewport: { width: 1280, height: 720 },
};

export async function captureStoryInternal(
  context: BrowserContext,
  storybookUrl: string,
  storyId: string,
  options: CaptureOptions = {}
): Promise<CaptureResult> {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const startTime = Date.now();
  const storyUrl = `${storybookUrl}/iframe.html?id=${storyId}&viewMode=story`;

  const consoleOutput: ConsoleMessage[] = [];
  const captureErrors: CaptureError[] = [];
  const page = await context.newPage();

  if (opts.viewport) await page.setViewportSize(opts.viewport);

  page.on('console', msg => {
    consoleOutput.push({ type: msg.type() as any, text: msg.text(), timestamp: Date.now() });
  });

  let pageError: Error | null = null;
  page.on('pageerror', err => { pageError = err; });

  let verification: VerificationResult | undefined;
  let screenshot: ScreenshotResult | undefined;
  let figmaLayers: any;
  let domSnapshot: string | undefined;

  try {
    await page.goto(storyUrl, { timeout: opts.timeout });
    await page.waitForSelector(opts.waitForSelector, { timeout: opts.timeout });
    if (opts.settleDelay > 0) await page.waitForTimeout(opts.settleDelay);

    if (opts.verify) {
      verification = await runVerification(page, opts.timeout, pageError, consoleOutput);
    }

    const shouldScreenshot = opts.screenshot === true || opts.screenshot === 'always' ||
      (opts.screenshot === 'on-failure' && verification?.status === 'failed');

    if (shouldScreenshot) {
      try {
        screenshot = await captureScreenshot(page, storyId, opts.screenshotDir, opts.artifactBaseUrl);
      } catch (err) {
        captureErrors.push({ output: 'screenshot', message: String(err) });
      }
    }

    if (opts.figmaLayers) {
      try {
        figmaLayers = await extractFigmaLayers(page, opts.waitForSelector, opts.figmaLayers);
      } catch (err) {
        captureErrors.push({ output: 'figmaLayers', message: String(err) });
      }
    }

    if (opts.domSnapshot) {
      try {
        domSnapshot = await page.content();
      } catch (err) {
        captureErrors.push({ output: 'domSnapshot', message: String(err) });
      }
    }
  } finally {
    await page.close();
  }

  return {
    storyId,
    url: storyUrl,
    duration: Date.now() - startTime,
    verification,
    screenshot,
    figmaLayers,
    domSnapshot,
    consoleOutput: consoleOutput.length > 0 ? consoleOutput : undefined,
    captureErrors: captureErrors.length > 0 ? captureErrors : undefined,
  };
}

// Standalone function (creates/destroys browser)
export async function captureStory(
  storybookUrl: string,
  storyId: string,
  options?: CaptureOptions
): Promise<CaptureResult> {
  const { createBrowserSession } = await import('./browser-session.js');
  const session = await createBrowserSession();
  try {
    return await session.capture(storybookUrl, storyId, options);
  } finally {
    await session.close();
  }
}

async function runVerification(page: Page, timeout: number, pageError: Error | null, consoleOutput: ConsoleMessage[]): Promise<VerificationResult> {
  // ... (verification logic from story-executor.ts)
}

async function captureScreenshot(page: Page, storyId: string, screenshotDir?: string, artifactBaseUrl?: string): Promise<ScreenshotResult> {
  // ... (screenshot logic)
}
```

### 8) [`scry-sbcov/src/core/story-executor.ts`](scry-sbcov/src/core/story-executor.ts)

Refactor to use `captureStoryInternal` internally:

```typescript
// Import the new capture primitive
import { captureStoryInternal } from './story-capture.js';

// Replace executeStory() internals (lines 163-409) with:
async function executeStory(
  story: ParsedStory,
  file: ParsedStoryFile,
  context: BrowserContext,
  storybookUrl: string,
  timeout: number,
  screenshotDir: string,
  captureScreenshot: boolean,
  captureDomSnapshot: boolean,
  artifactBaseUrl: string | undefined,
  verbose = false
): Promise<StoryExecutionResult> {
  const componentName = file.meta.componentName || 'Unknown';

  // Use the new capture primitive
  const captureResult = await captureStoryInternal(context, storybookUrl, story.storyId, {
    verify: true,
    screenshot: captureScreenshot ? 'on-failure' : false,
    domSnapshot: captureDomSnapshot,
    timeout,
    screenshotDir,
    artifactBaseUrl,
  });

  // Map CaptureResult to StoryExecutionResult for backward compatibility
  return mapToExecutionResult(captureResult, story, file, componentName, screenshotDir, artifactBaseUrl);
}

function mapToExecutionResult(capture: CaptureResult, story: ParsedStory, file: ParsedStoryFile, componentName: string, screenshotDir: string, artifactBaseUrl?: string): StoryExecutionResult {
  // ... mapping logic preserving exact existing structure
}
```

### 9) [`scry-sbcov/src/index.ts`](scry-sbcov/src/index.ts)

Export new public API:

```typescript
// New exports
export { captureStory } from './core/story-capture.js';
export { createBrowserSession } from './core/browser-session.js';

// New type exports
export type {
  CaptureOptions,
  CaptureResult,
  VerificationResult,
  ScreenshotResult,
  ConsoleMessage,
  CaptureError,
  BrowserSession,
  BrowserSessionOptions,
  FigmaLayerOptions,
  LayerNode,
} from './types/index.js';

// Keep all existing exports unchanged
```

### 10) [`scry-sbcov/scripts/bundle-html-to-figma.mjs`](scry-sbcov/scripts/bundle-html-to-figma.mjs) (NEW)

Build script to bundle html-to-figma:

```javascript
import { build } from 'esbuild';
import { writeFileSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

async function bundleHtmlToFigma() {
  const result = await build({
    entryPoints: [resolve(__dirname, '../../html2fig/html-to-figma/src/browser/index.ts')],
    bundle: true,
    format: 'iife',
    globalName: 'HtmlToFigma',
    write: false,
    minify: true,
    target: 'es2020',
  });

  const bundledCode = result.outputFiles[0].text;

  const output = `
// Auto-generated - DO NOT EDIT
export const HTML_TO_FIGMA_BUNDLE = ${JSON.stringify(bundledCode + '\\nwindow.htmlToFigma = HtmlToFigma.htmlToFigma;')};

export async function injectHtmlToFigma(page) {
  await page.addScriptTag({ content: HTML_TO_FIGMA_BUNDLE });
}

export async function extractWithHtmlToFigma(page, selector) {
  return page.evaluate((sel) => window.htmlToFigma(sel), selector);
}
`;

  writeFileSync(resolve(__dirname, '../src/figma/html-to-figma.bundle.ts'), output);
}

bundleHtmlToFigma().catch(console.error);
```

### 11) [`scry-sbcov/package.json`](scry-sbcov/package.json)

Add dependencies and scripts:

```json
{
  "scripts": {
    "prebuild": "npm run build:figma-bundle",
    "build:figma-bundle": "node scripts/bundle-html-to-figma.mjs"
  },
  "devDependencies": {
    "esbuild": "^0.20.0"
  }
}
```

---

## Tests

### New test file: `scry-sbcov/tests/story-capture.test.ts`

```typescript
describe('captureStoryInternal', () => {
  it('returns verification when verify: true');
  it('captures screenshot when screenshot: always');
  it('captures screenshot only on failure when screenshot: on-failure');
  it('extracts figma layers with html-to-figma');
  it('extracts figma layers with code-to-design');
  it('isolates errors per output type');
});

describe('createBrowserSession', () => {
  it('reuses browser across captures');
  it('throws when capturing after close');
  it('respects concurrency in captureMany');
});
```

### Backward compatibility: ensure all existing tests pass unchanged

---

## Acceptance Criteria

- [ ] `captureStory()` exported from package
- [ ] `createBrowserSession()` exported from package
- [ ] All outputs work independently (verify, screenshot, figmaLayers, domSnapshot)
- [ ] Both Figma converters work (html-to-figma, code-to-design)
- [ ] `executeStories()` produces identical output (backward compatible)
- [ ] All existing tests pass
- [ ] New tests for capture functionality pass
