name: Claude Agent

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write

jobs:
  claude:
    if: |
      (github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'claude')) ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude'))
    runs-on: ubuntu-latest

    env:
      PROJECT_NUMBER: "1"  # Update after creating the project
      PROJECT_OWNER: "epinnock"

    steps:
      - uses: actions/checkout@v4

      # --- Move issue to "In Progress" on the project board ---

      - name: Move issue to In Progress
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
        continue-on-error: true
        run: |
          # Get project and Status field metadata
          PROJECT_DATA=$(gh api graphql -f query='
            query($owner: String!, $number: Int!) {
              user(login: $owner) {
                projectV2(number: $number) {
                  id
                  field(name: "Status") {
                    ... on ProjectV2SingleSelectField {
                      id
                      options { id name }
                    }
                  }
                }
              }
            }' -f owner="${PROJECT_OWNER}" -F number="${PROJECT_NUMBER}" 2>/dev/null) || exit 0

          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.id')
          FIELD_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.field.id')
          OPTION_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.field.options[] | select(.name == "In Progress") | .id')

          [ -z "$PROJECT_ID" ] || [ "$PROJECT_ID" = "null" ] && exit 0
          [ -z "$OPTION_ID" ] || [ "$OPTION_ID" = "null" ] && exit 0

          # Ensure issue is on the project
          ITEM_ID=$(gh api graphql -f query='
            mutation($projectId: ID!, $contentId: ID!) {
              addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                item { id }
              }
            }' -f projectId="$PROJECT_ID" -f contentId="${{ github.event.issue.node_id }}" \
            --jq '.data.addProjectV2ItemById.item.id' 2>/dev/null) || exit 0

          # Set status to In Progress
          gh api graphql -f query='
            mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
              updateProjectV2ItemFieldValue(input: {
                projectId: $projectId
                itemId: $itemId
                fieldId: $fieldId
                value: { singleSelectOptionId: $optionId }
              }) { projectV2Item { id } }
            }' -f projectId="$PROJECT_ID" -f itemId="$ITEM_ID" -f fieldId="$FIELD_ID" -f optionId="$OPTION_ID" 2>/dev/null || true

          echo "Moved issue #${{ github.event.issue.number }} to In Progress"

      # --- Auto-add dependency labels from repo-map.yml ---

      - name: Auto-add dependency labels
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          # Read current labels
          LABELS=$(gh issue view "$ISSUE_NUMBER" --repo epinnock/scry-ops --json labels --jq '.labels[].name')

          # Service-to-service dependencies (derived from repo-map.yml depends_on)
          # scry-node depends on upload-service
          if echo "$LABELS" | grep -q "scry-node"; then
            gh issue edit "$ISSUE_NUMBER" --repo epinnock/scry-ops --add-label "upload-service" 2>/dev/null || true
          fi
          # cdn-service depends on upload-service (shared R2 + Firestore contracts)
          if echo "$LABELS" | grep -q "cdn-service"; then
            gh issue edit "$ISSUE_NUMBER" --repo epinnock/scry-ops --add-label "upload-service" 2>/dev/null || true
          fi
          # dashboard depends on upload-service (shared Firestore schemas)
          if echo "$LABELS" | grep -q "dashboard"; then
            gh issue edit "$ISSUE_NUMBER" --repo epinnock/scry-ops --add-label "upload-service" 2>/dev/null || true
          fi

          # Re-read labels after auto-additions for downstream steps
          echo "Final labels:"
          gh issue view "$ISSUE_NUMBER" --repo epinnock/scry-ops --json labels --jq '.labels[].name'

      # --- Conditional cross-repo checkouts based on labels ---

      - name: Checkout upload-service
        if: contains(github.event.issue.labels.*.name, 'upload-service')
        uses: actions/checkout@v4
        with:
          repository: epinnock/scry-storybook-upload-service
          token: ${{ secrets.CROSS_REPO_PAT }}
          path: services/scry-storybook-upload-service

      - name: Checkout cdn-service
        if: contains(github.event.issue.labels.*.name, 'cdn-service')
        uses: actions/checkout@v4
        with:
          repository: epinnock/scry-cdn-service
          token: ${{ secrets.CROSS_REPO_PAT }}
          path: services/scry-cdn-service

      - name: Checkout dashboard
        if: contains(github.event.issue.labels.*.name, 'dashboard')
        uses: actions/checkout@v4
        with:
          repository: epinnock/scry-developer-dashboard
          token: ${{ secrets.CROSS_REPO_PAT }}
          path: services/scry-developer-dashboard

      - name: Checkout scry-node
        if: contains(github.event.issue.labels.*.name, 'scry-node')
        uses: actions/checkout@v4
        with:
          repository: epinnock/scry-node
          token: ${{ secrets.CROSS_REPO_PAT }}
          path: services/scry-node

      - name: Checkout sbcov
        if: contains(github.event.issue.labels.*.name, 'sbcov')
        uses: actions/checkout@v4
        with:
          repository: epinnock/scry-sbcov
          token: ${{ secrets.CROSS_REPO_PAT }}
          path: services/scry-sbcov

      - name: Checkout search-api
        if: contains(github.event.issue.labels.*.name, 'search-api')
        uses: actions/checkout@v4
        with:
          repository: epinnock/scry-nextjs
          token: ${{ secrets.CROSS_REPO_PAT }}
          path: services/scry-nextjs

      - name: Checkout landing-page
        if: contains(github.event.issue.labels.*.name, 'landing-page')
        uses: actions/checkout@v4
        with:
          repository: epinnock/scry-landing-page
          token: ${{ secrets.CROSS_REPO_PAT }}
          path: services/scry-landing-page

      - name: Checkout scry-link
        if: contains(github.event.issue.labels.*.name, 'scry-link')
        uses: actions/checkout@v4
        with:
          repository: epinnock/scry-link
          token: ${{ secrets.CROSS_REPO_PAT }}
          path: services/scry-link

      # --- Build --add-dir flags for all checked out services ---

      - name: Build add-dir args
        id: dirs
        run: |
          ARGS=""
          for dir in services/*/; do
            if [ -d "$dir" ]; then
              ARGS="$ARGS --add-dir ${{ github.workspace }}/$dir"
            fi
          done
          echo "add_dirs=$ARGS" >> "$GITHUB_OUTPUT"
          echo "Checked out services: $(ls services/ 2>/dev/null || echo 'none')"

      # --- Run Claude ---

      - uses: anthropics/claude-code-action@01e756b34ef7a1447e9508f674143b07d20c2631 # v1.0.39 - last working version before SDK 0.2.27 broke OAuth
        id: claude
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          model: claude-sonnet-4-5-20250929
          allowed_tools: "Edit,MultiEdit,Glob,Grep,LS,Read,Write,Bash"
          claude_args: |
            ${{ steps.dirs.outputs.add_dirs }}
            --max-turns 50

      # --- Push changes back to source repos ---

      - name: Push changes to source repos
        if: success()
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
        shell: bash
        run: |
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

          declare -A REPO_MAP
          REPO_MAP[scry-storybook-upload-service]="epinnock/scry-storybook-upload-service"
          REPO_MAP[scry-cdn-service]="epinnock/scry-cdn-service"
          REPO_MAP[scry-developer-dashboard]="epinnock/scry-developer-dashboard"
          REPO_MAP[scry-node]="epinnock/scry-node"
          REPO_MAP[scry-sbcov]="epinnock/scry-sbcov"
          REPO_MAP[scry-nextjs]="epinnock/scry-nextjs"
          REPO_MAP[scry-landing-page]="epinnock/scry-landing-page"
          REPO_MAP[scry-link]="epinnock/scry-link"

          # --- Pass 1: Push all branches, collect services with changes ---
          declare -A PUSHED_BRANCHES  # service_name -> branch_name
          declare -A PUSHED_REPOS     # service_name -> target_repo

          for dir in services/*/; do
            [ ! -d "$dir" ] && continue
            service_name=$(basename "$dir")
            target_repo="${REPO_MAP[$service_name]}"
            [ -z "$target_repo" ] && continue

            cd "${{ github.workspace }}/$dir"

            if [ -z "$(git status --porcelain)" ]; then
              echo "No changes in $service_name, skipping"
              cd "${{ github.workspace }}"
              continue
            fi

            echo "Changes detected in $service_name, pushing to $target_repo"

            BRANCH="claude/scry-ops-issue-${ISSUE_NUMBER}"

            git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${target_repo}.git"
            git checkout -b "$BRANCH"
            git add -A
            git commit -m "${ISSUE_TITLE} - Automated by scry-ops#${ISSUE_NUMBER}"
            git push origin "$BRANCH"

            PUSHED_BRANCHES[$service_name]="$BRANCH"
            PUSHED_REPOS[$service_name]="$target_repo"

            cd "${{ github.workspace }}"
          done

          # --- Pass 2: Create PRs with sibling cross-references ---
          CHANGED_SERVICES=("${!PUSHED_BRANCHES[@]}")
          MULTI_SERVICE=$(( ${#CHANGED_SERVICES[@]} > 1 ? 1 : 0 ))

          PR_LINKS=""

          for service_name in "${CHANGED_SERVICES[@]}"; do
            target_repo="${PUSHED_REPOS[$service_name]}"
            branch="${PUSHED_BRANCHES[$service_name]}"

            # Build PR body
            PR_BODY="Automated changes from [scry-ops#${ISSUE_NUMBER}](https://github.com/epinnock/scry-ops/issues/${ISSUE_NUMBER})."

            if [ "$MULTI_SERVICE" -eq 1 ]; then
              PR_BODY="${PR_BODY}

          ## Related PRs

          This is part of a cross-service change from scry-ops#${ISSUE_NUMBER}. Sibling PRs:"
              for sibling in "${CHANGED_SERVICES[@]}"; do
                sibling_repo="${PUSHED_REPOS[$sibling]}"
                if [ "$sibling" != "$service_name" ]; then
                  PR_BODY="${PR_BODY}
          - **${sibling}**: \`${sibling_repo}\` (branch: \`${branch}\`)"
                fi
              done
            fi

            PR_BODY="${PR_BODY}

          ---
          Generated by Claude Code."

            PR_URL=$(gh pr create \
              --repo "$target_repo" \
              --head "$branch" \
              --title "${ISSUE_TITLE}" \
              --body "$PR_BODY" \
              2>&1) || true

            echo "Result: $PR_URL"
            PR_LINKS="${PR_LINKS}- **${service_name}**: ${PR_URL}\n"
          done

          # --- Comment on the orchestrator issue with all PR links ---
          if [ -n "$PR_LINKS" ]; then
            COMMENT_BODY="### PRs created in source repos\n\n${PR_LINKS}"
            if [ "$MULTI_SERVICE" -eq 1 ]; then
              COMMENT_BODY="${COMMENT_BODY}\n> Cross-service change: ${#CHANGED_SERVICES[@]} repos modified. Review all PRs together."
            fi
            printf "$COMMENT_BODY" | \
              gh issue comment "$ISSUE_NUMBER" --repo epinnock/scry-ops --body-file -
          fi

      # --- Move issue to "In Review" after PRs are created ---

      - name: Move issue to In Review
        if: success()
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
        continue-on-error: true
        run: |
          PROJECT_DATA=$(gh api graphql -f query='
            query($owner: String!, $number: Int!) {
              user(login: $owner) {
                projectV2(number: $number) {
                  id
                  field(name: "Status") {
                    ... on ProjectV2SingleSelectField {
                      id
                      options { id name }
                    }
                  }
                }
              }
            }' -f owner="${PROJECT_OWNER}" -F number="${PROJECT_NUMBER}" 2>/dev/null) || exit 0

          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.id')
          FIELD_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.field.id')
          OPTION_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.field.options[] | select(.name == "In Review") | .id')

          [ -z "$PROJECT_ID" ] || [ "$PROJECT_ID" = "null" ] && exit 0
          [ -z "$OPTION_ID" ] || [ "$OPTION_ID" = "null" ] && exit 0

          # Get the item ID (issue should already be on the project from earlier step)
          ITEM_ID=$(gh api graphql -f query='
            mutation($projectId: ID!, $contentId: ID!) {
              addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                item { id }
              }
            }' -f projectId="$PROJECT_ID" -f contentId="${{ github.event.issue.node_id }}" \
            --jq '.data.addProjectV2ItemById.item.id' 2>/dev/null) || exit 0

          gh api graphql -f query='
            mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
              updateProjectV2ItemFieldValue(input: {
                projectId: $projectId
                itemId: $itemId
                fieldId: $fieldId
                value: { singleSelectOptionId: $optionId }
              }) { projectV2Item { id } }
            }' -f projectId="$PROJECT_ID" -f itemId="$ITEM_ID" -f fieldId="$FIELD_ID" -f optionId="$OPTION_ID" 2>/dev/null || true

          echo "Moved issue #${{ github.event.issue.number }} to In Review"
