name: AI Agent

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write

jobs:
  agent:
    if: |
      (github.event_name == 'issues' && (
        contains(github.event.issue.labels.*.name, 'claude') ||
        contains(github.event.issue.labels.*.name, 'codex')
      )) ||
      (github.event_name == 'issue_comment' && (
        contains(github.event.comment.body, '@claude') ||
        contains(github.event.comment.body, '@codex')
      ))
    runs-on: ubuntu-latest

    env:
      PROJECT_NUMBER: "1"  # Update after creating the project
      PROJECT_OWNER: "epinnock"
      DEFAULT_CODEX_MODEL: "codex-5.3"
      DEFAULT_CLAUDE_MODEL: "claude-opus-4-6"

    steps:
      - uses: actions/checkout@v4

      # --- Move issue to "In Progress" on the project board ---

      - name: Move issue to In Progress
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
        continue-on-error: true
        run: |
          # Get project and Status field metadata
          PROJECT_DATA=$(gh api graphql -f query='
            query($owner: String!, $number: Int!) {
              user(login: $owner) {
                projectV2(number: $number) {
                  id
                  field(name: "Status") {
                    ... on ProjectV2SingleSelectField {
                      id
                      options { id name }
                    }
                  }
                }
              }
            }' -f owner="${PROJECT_OWNER}" -F number="${PROJECT_NUMBER}" 2>/dev/null) || exit 0

          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.id')
          FIELD_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.field.id')
          OPTION_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.field.options[] | select(.name == "In Progress") | .id')

          [ -z "$PROJECT_ID" ] || [ "$PROJECT_ID" = "null" ] && exit 0
          [ -z "$OPTION_ID" ] || [ "$OPTION_ID" = "null" ] && exit 0

          # Ensure issue is on the project
          ITEM_ID=$(gh api graphql -f query='
            mutation($projectId: ID!, $contentId: ID!) {
              addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                item { id }
              }
            }' -f projectId="$PROJECT_ID" -f contentId="${{ github.event.issue.node_id }}" \
            --jq '.data.addProjectV2ItemById.item.id' 2>/dev/null) || exit 0

          # Set status to In Progress
          gh api graphql -f query='
            mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
              updateProjectV2ItemFieldValue(input: {
                projectId: $projectId
                itemId: $itemId
                fieldId: $fieldId
                value: { singleSelectOptionId: $optionId }
              }) { projectV2Item { id } }
            }' -f projectId="$PROJECT_ID" -f itemId="$ITEM_ID" -f fieldId="$FIELD_ID" -f optionId="$OPTION_ID" 2>/dev/null || true

          echo "Moved issue #${{ github.event.issue.number }} to In Progress"

      # --- Auto-add dependency labels from repo-map.yml ---

      - name: Auto-add dependency labels
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          # Read current labels
          LABELS=$(gh issue view "$ISSUE_NUMBER" --repo epinnock/scry-ops --json labels --jq '.labels[].name')

          # Service-to-service dependency auto-labeling from repo-map.yml.
          while IFS=$'\t' read -r service_label dependency_label; do
            [ -z "$service_label" ] && continue
            [ -z "$dependency_label" ] && continue
            if echo "$LABELS" | grep -Fxq "$service_label"; then
              echo "Adding dependency label: ${service_label} -> ${dependency_label}"
              gh issue edit "$ISSUE_NUMBER" --repo epinnock/scry-ops --add-label "$dependency_label" 2>/dev/null || true
            fi
          done < <(bash scripts/list-service-dependencies.sh)

          # Re-read labels after auto-additions for downstream steps
          echo "Final labels:"
          gh issue view "$ISSUE_NUMBER" --repo epinnock/scry-ops --json labels --jq '.labels[].name'

      # --- Checkout labeled service repos dynamically from repo-map.yml ---

      - name: Checkout labeled services
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          mkdir -p services
          LABELS=$(gh issue view "$ISSUE_NUMBER" --repo epinnock/scry-ops --json labels --jq '.labels[].name')

          while IFS=$'\t' read -r service_name repo label _description; do
            [ -z "$service_name" ] && continue
            [ -z "$repo" ] && continue
            [ -z "$label" ] && continue

            # scry-ops is already checked out as the workspace root.
            if [ "$service_name" = "scry-ops" ]; then
              continue
            fi

            if echo "$LABELS" | grep -Fxq "$label"; then
              target_dir="services/${service_name}"
              if [ -d "$target_dir/.git" ]; then
                echo "Already checked out: $service_name"
                continue
              fi
              echo "Checking out ${repo} -> ${target_dir}"
              git clone "https://x-access-token:${GH_TOKEN}@github.com/${repo}.git" "$target_dir"
            fi
          done < <(bash scripts/list-services.sh)

      # --- Build --add-dir flags for all checked out services ---

      - name: Build add-dir args
        id: dirs
        run: |
          ARGS=""
          for dir in services/*/; do
            if [ -d "$dir" ]; then
              ARGS="$ARGS --add-dir ${{ github.workspace }}/$dir"
            fi
          done
          echo "add_dirs=$ARGS" >> "$GITHUB_OUTPUT"
          echo "Checked out services: $(ls services/ 2>/dev/null || echo 'none')"

      # --- Select AI agent ---

      - name: Select AI agent
        id: agent
        env:
          ISSUE_LABELS_JSON: ${{ toJSON(github.event.issue.labels.*.name) }}
          COMMENT_BODY: ${{ github.event_name == 'issue_comment' && github.event.comment.body || '' }}
        run: |
          SELECTED_AGENT="codex"
          AGENT_NAME="Codex"
          BRANCH_PREFIX="codex"

          if echo "$COMMENT_BODY" | grep -qi "@claude"; then
            SELECTED_AGENT="claude"
            AGENT_NAME="Claude Code"
            BRANCH_PREFIX="claude"
          elif echo "$COMMENT_BODY" | grep -qi "@codex"; then
            SELECTED_AGENT="codex"
            AGENT_NAME="Codex"
            BRANCH_PREFIX="codex"
          elif echo "$ISSUE_LABELS_JSON" | grep -q '"claude"'; then
            SELECTED_AGENT="claude"
            AGENT_NAME="Claude Code"
            BRANCH_PREFIX="claude"
          fi

          echo "Selected agent: ${SELECTED_AGENT}"
          echo "agent=${SELECTED_AGENT}" >> "$GITHUB_OUTPUT"
          echo "agent_name=${AGENT_NAME}" >> "$GITHUB_OUTPUT"
          echo "branch_prefix=${BRANCH_PREFIX}" >> "$GITHUB_OUTPUT"

      # --- Switch git remote to PAT so agents can push workflow files ---

      - name: Configure git remote with PAT
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
        run: |
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git"
          echo "Git remote updated to use CROSS_REPO_PAT (includes workflow scope)"

      # --- Run Codex (default) ---

      - name: Run Codex
        if: steps.agent.outputs.agent == 'codex'
        id: codex
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          model: ${{ env.DEFAULT_CODEX_MODEL }}
          sandbox: workspace-write
          safety-strategy: drop-sudo
          codex-args: --full-auto --max-turns 50
          prompt: |
            Work on scry-ops issue #${{ github.event.issue.number }}: ${{ github.event.issue.title }}.

            Issue body:
            ${{ github.event.issue.body }}

            Labels:
            ${{ join(github.event.issue.labels.*.name, ', ') }}

            Service repos are checked out under ./services.
            Follow scry-ops/CLAUDE.md and each checked-out service CLAUDE.md.
            Do not run git commit or git push. This workflow handles commits and PR creation.

      # --- Run Claude (opt-in via label/comment) ---

      - name: Run Claude
        if: steps.agent.outputs.agent == 'claude'
        id: claude
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          model: ${{ env.DEFAULT_CLAUDE_MODEL }}
          allowed_tools: "Edit,MultiEdit,Glob,Grep,LS,Read,Write,Bash"
          claude_args: |
            ${{ steps.dirs.outputs.add_dirs }}
            --max-turns 50

      # --- Push changes back to source repos ---

      - name: Push changes to source repos
        if: success()
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          AGENT_NAME: ${{ steps.agent.outputs.agent_name }}
          BRANCH_PREFIX: ${{ steps.agent.outputs.branch_prefix }}
        shell: bash
        run: |
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"

          declare -A REPO_MAP
          while IFS=$'\t' read -r service_name repo _label _description; do
            [ -z "$service_name" ] && continue
            [ -z "$repo" ] && continue
            REPO_MAP[$service_name]="$repo"
          done < <(bash scripts/list-services.sh)

          # --- Pass 1: Push all branches, collect services with changes ---
          declare -A PUSHED_BRANCHES  # service_name -> branch_name
          declare -A PUSHED_REPOS     # service_name -> target_repo

          # Handle root scry-ops changes separately (excluding checked-out service repos).
          cd "${{ github.workspace }}"
          ROOT_STATUS=$(git status --porcelain -- . ':(exclude)services')
          if [ -n "$ROOT_STATUS" ]; then
            echo "Changes detected in scry-ops root, pushing to epinnock/scry-ops"
            BRANCH="${BRANCH_PREFIX}/scry-ops-issue-${ISSUE_NUMBER}"

            git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/epinnock/scry-ops.git"
            git checkout -b "$BRANCH"
            git add -A -- . ':(exclude)services'

            if [ -n "$(git diff --cached --name-only)" ]; then
              git commit -m "${ISSUE_TITLE} - Automated by scry-ops#${ISSUE_NUMBER}"
              git push origin "$BRANCH"
              PUSHED_BRANCHES[scry-ops]="$BRANCH"
              PUSHED_REPOS[scry-ops]="epinnock/scry-ops"
            else
              echo "No committable scry-ops root changes after filtering, skipping"
            fi
          else
            echo "No scry-ops root changes detected"
          fi

          # --- Pass 1b: Push service repo branches ---
          for dir in services/*/; do
            [ ! -d "$dir" ] && continue
            service_name=$(basename "$dir")
            target_repo="${REPO_MAP[$service_name]}"
            [ -z "$target_repo" ] && continue

            cd "${{ github.workspace }}/$dir"

            if [ -z "$(git status --porcelain)" ]; then
              echo "No changes in $service_name, skipping"
              cd "${{ github.workspace }}"
              continue
            fi

            echo "Changes detected in $service_name, pushing to $target_repo"

            BRANCH="${BRANCH_PREFIX}/scry-ops-issue-${ISSUE_NUMBER}"

            git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${target_repo}.git"
            git checkout -b "$BRANCH"
            git add -A
            git commit -m "${ISSUE_TITLE} - Automated by scry-ops#${ISSUE_NUMBER}"
            git push origin "$BRANCH"

            PUSHED_BRANCHES[$service_name]="$BRANCH"
            PUSHED_REPOS[$service_name]="$target_repo"

            cd "${{ github.workspace }}"
          done

          # --- Pass 2: Create PRs with sibling cross-references ---
          CHANGED_SERVICES=("${!PUSHED_BRANCHES[@]}")
          MULTI_SERVICE=$(( ${#CHANGED_SERVICES[@]} > 1 ? 1 : 0 ))

          PR_LINKS=""

          for service_name in "${CHANGED_SERVICES[@]}"; do
            target_repo="${PUSHED_REPOS[$service_name]}"
            branch="${PUSHED_BRANCHES[$service_name]}"

            # Build PR body
            PR_BODY="Automated changes from [scry-ops#${ISSUE_NUMBER}](https://github.com/epinnock/scry-ops/issues/${ISSUE_NUMBER})."

            if [ "$MULTI_SERVICE" -eq 1 ]; then
              PR_BODY="${PR_BODY}

          ## Related PRs

          This is part of a cross-service change from scry-ops#${ISSUE_NUMBER}. Sibling PRs:"
              for sibling in "${CHANGED_SERVICES[@]}"; do
                sibling_repo="${PUSHED_REPOS[$sibling]}"
                if [ "$sibling" != "$service_name" ]; then
                  PR_BODY="${PR_BODY}
          - **${sibling}**: \`${sibling_repo}\` (branch: \`${branch}\`)"
                fi
              done
            fi

            PR_BODY="${PR_BODY}

          ---
          Generated by ${AGENT_NAME}."

            PR_URL=$(gh pr create \
              --repo "$target_repo" \
              --head "$branch" \
              --title "${ISSUE_TITLE}" \
              --body "$PR_BODY" \
              2>&1) || true

            echo "Result: $PR_URL"
            PR_LINKS="${PR_LINKS}- **${service_name}**: ${PR_URL}\n"
          done

          # --- Comment on the orchestrator issue with all PR links ---
          if [ -n "$PR_LINKS" ]; then
            COMMENT_BODY="### PRs created in source repos\n\n${PR_LINKS}"
            if [ "$MULTI_SERVICE" -eq 1 ]; then
              COMMENT_BODY="${COMMENT_BODY}\n> Cross-service change: ${#CHANGED_SERVICES[@]} repos modified. Review all PRs together."
            fi
            printf "$COMMENT_BODY" | \
              gh issue comment "$ISSUE_NUMBER" --repo epinnock/scry-ops --body-file -
          fi

      # --- Move issue to "In Review" after PRs are created ---

      - name: Move issue to In Review
        if: success()
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
        continue-on-error: true
        run: |
          PROJECT_DATA=$(gh api graphql -f query='
            query($owner: String!, $number: Int!) {
              user(login: $owner) {
                projectV2(number: $number) {
                  id
                  field(name: "Status") {
                    ... on ProjectV2SingleSelectField {
                      id
                      options { id name }
                    }
                  }
                }
              }
            }' -f owner="${PROJECT_OWNER}" -F number="${PROJECT_NUMBER}" 2>/dev/null) || exit 0

          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.id')
          FIELD_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.field.id')
          OPTION_ID=$(echo "$PROJECT_DATA" | jq -r '.data.user.projectV2.field.options[] | select(.name == "In Review") | .id')

          [ -z "$PROJECT_ID" ] || [ "$PROJECT_ID" = "null" ] && exit 0
          [ -z "$OPTION_ID" ] || [ "$OPTION_ID" = "null" ] && exit 0

          # Get the item ID (issue should already be on the project from earlier step)
          ITEM_ID=$(gh api graphql -f query='
            mutation($projectId: ID!, $contentId: ID!) {
              addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                item { id }
              }
            }' -f projectId="$PROJECT_ID" -f contentId="${{ github.event.issue.node_id }}" \
            --jq '.data.addProjectV2ItemById.item.id' 2>/dev/null) || exit 0

          gh api graphql -f query='
            mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
              updateProjectV2ItemFieldValue(input: {
                projectId: $projectId
                itemId: $itemId
                fieldId: $fieldId
                value: { singleSelectOptionId: $optionId }
              }) { projectV2Item { id } }
            }' -f projectId="$PROJECT_ID" -f itemId="$ITEM_ID" -f fieldId="$FIELD_ID" -f optionId="$OPTION_ID" 2>/dev/null || true

          echo "Moved issue #${{ github.event.issue.number }} to In Review"
